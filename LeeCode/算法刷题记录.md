### 目录

[TOC]

## 剑指Offer第二版

### 基础方法梳理

#### **数据结构**

- 类型 `Types`

  - 容器 `Collection`

- 摘要 `Abstract`

  - 关联数组 `Associative array`

  - 列表 `List`

  - 队列 `Queue` 双结束队列 `Double-ended queue` 优先级队列 `Priority queue`

  - 集合 `Set`（多集不相交）

- 数组 `Arrays`

  - 位数组 `Bit array`

  - 圆形队列 `Circular buffer`（环形缓冲区）

  - 动态数组 `Dynamic array`

  - 哈希表 `Hash table`

  - 哈希数组树 `Hash array tree`

  - 稀疏矩阵 `Sparse matrix`

- 链接`Linked`

  - 关联列表 `Association list`

  - 单链表 `Linked list`

  - 跳表 `Skip list`

  - 松散链表 `Unrolled linked list`

  - 异或链表 `XOR linked list`

- 树 `Tree`

  - B树 `B tree`

  - 二叉搜索树 `Binary search tree` （AA树 `AA tree`、平衡二叉树 `AVL tree`、红黑树 `Red-black tree`、自平衡二叉树 `Self-balancing tree`、伸展树 `Splay tree`）

  - 堆 `Heap`（二叉堆 `Binary heap`、二项堆 `Binominal heap`、斐波那契堆 `Fibonacci heap`）

  - R-树 `R-tree`（R* 树 `R* tree`、R+树 `R+ tree`）

  - 字典树 `Trie`（哈希数 `Hash tree`）

- 图 `Graphs`
  - 二叉判定图 `Binary decision diagram`
  - 有向无环图 `directed acyclic graph`

#### 思维方法

- 试错 `Trial and error`法（蛮力法）[是重复的，不同的尝试，一直持续到成功，或直到练习者停止尝试。]

- 分治法（分而治之）[]

**递归**

- 分治[先把问题分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。如果这些子问题还较大，难以解决，可以再把它们分成几个更小的子问题，以此类推，直至可以直接求出解为止。]

  - 二分搜索

- 回溯 [通常使用最简单的递归方法来实现]

  - 八皇后问题

  - 数独

- 动态规划[`与分治的共性是找到重复子问题`]

  - 关键看有无最优子结构

## 排序

![img](https://iknow-pic.cdn.bcebos.com/eaf81a4c510fd9f9ef7d68c82b2dd42a2834a42c)

**稳定排序**：↓

- 冒泡排序
- 插入排序
- 归并排序
- 基数排序

### **冒泡排序**

```js
// 冒泡排序（交换型）
const bubbleSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[i]) {
        [arr[j], arr[i]] = [arr[i], arr[j]];
      }
    }
  }
  return arr;
};
```

### **直接插入排序**

```js
// 直接插入排序
// 分为有序区和无序区，无序区往有序区正确插入，直到无序区清空。
const insertSort = (array) => {
  // i表示：拿出来的无序区的数字的下标
  for (let i = 1; i < array.length; i++) {
    //   j表示：有序区的最后一个数的下标
    let temp = array[i],
      j = i - 1;
    while (j >= 0 && array[j] > temp) {
      array[j + 1] = array[j];
      j -= 1;
    }
    array[j + 1] = temp;
  }
  return array;
};
```

### **归并排序**

```js
// 归并排序
// 分为两个函数，主函数递归调用归并算法。
const mergeSort = (array) => {
  
  // 归并方法
  const merge = (left, right) => {
    let result = [];
    while (left.length && right.length) {
      if (left[0] <= right[0]) {
        result.push(left.shift());
      } else {
        result.push(right.shift());
      }
    }
    while (left.length) {
      result.push(left.shift());
    }
    while (right.length) {
      result.push(right.shift());
    }
    return result;
  };
  
  // 主方法调用归并方法
  let len = array.length;
  if (len < 2) {
    return array;
  }
  let mid = Math.floor(len / 2);
  let left = array.slice(0, mid);
  let right = array.slice(mid);
  return merge(mergeSort(left), mergeSort(right));
};
```

### 基数排序

二叉排序树排序

```

```

**不稳定排序**：↓

- 选择排序
- 希尔排序
- 堆排序
- 快速排序

### **直接选择排序**

```js
// 直接选择排序
// 简单思路是创建新数组，每次插入无序区最小的值。
// 改进之后，基于交换的思想，实现原地排序。
const selectSort = (arr) => {
  // 有序区和无序区， 更新无序区最小值的位置
  // 排n-1次就行了，剩下来那个肯定是最大值
  for (let i = 0; i < arr.length - 1; i++) {
    let min_local = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min_local] > arr[j]) {
        [arr[min_local], arr[j]] = [arr[j], arr[min_local]];
      }
    }
  }
  return arr;
};
```

### 希尔排序

### 堆排序

### **快速排序**

```jsx
  // 不稳定排序
// 快速排序（交换型）

// 快排：哨兵归位算法
const partition = (array, left, right) => { // partition：分治
  let temp = array[left];
  while (left < right) {
    // 如果右边的值比哨兵大，就直接左移一步，否则就交换。
    while (left < right && array[right] >= temp) {
      right--;
    }
    // 把右边的值放到左边的空位上
    array[left] = array[right];
    while (left < right && array[left] <= temp) {
      left++;
    }
    // 把左边的值放到右边的空位上
    array[right] = array[left];
  }
  array[left] = temp;
  // 返回归位之后哨兵的位置  
  return left;
};

// 递归调用自身即可
const quickSort = (array, left, right) => {
  if (left < right) {
    let mid = partition(array, left, right);
    quickSort(array, left, mid - 1);
    quickSort(array, mid + 1, right);
  }
  return array;
};

console.log(quickSort(num, 0, num.length - 1));
```

### 链表快排

```js
// 单项节点列表
// 声明链表节点
class Nodes {
  constructor(value) {
    this.val = value
    // 下一个节点
    this.next = undefined
  }
}

// 声明链表的数据结构
// 原生的 js 没有链表的数据结构
class NodeList {
  constructor(arr) {
    // 声明链头的头部节点
    let head = new Nodes(arr.shift())
    let next = head
    // 循环创建链表的数据结构
    arr.forEach(item => {
      next.next = new Nodes(item)
      next = next.next
    })
    return head
  }
}

// 创建单链表
const head = new NodeList(['5', '3', '6', '2', '7', '1', '4']); 

// 交换两个节点的值
let swap = (p, q) => {
  let val = p.val
  p.val = q.val
  q.val = val
}

// 寻找基准元素的节点
let partion = (begin, end) => {
  // 开始节点
  let val = begin.val
  // 上指针
  let p = begin
  // 下一个指针位置
  let q = begin.next

  // 如果 有下一个
  while(q !== end) {
    // 如果下一个数，小于当前的 val p 指针指向下一个
    if (q.val < val) {
      // 指针向下移动一位
      p = p.next
      swap(p, q)
    }
    q = q.next
  }
  // 让基准元素跑到中间去
  swap(p, begin)
  return p
}

// 排序
function sortList(begin, end) {
  if (begin !== end) {
    let part = partion(begin, end)
    // 递归左边元素
    sortList(begin, part)
    // 递归右边元素
    sortList(part.next, end)
  }
}
```

### 链表归并

```js
// 实现链表归并
let sortList = function(head) {
    return mergeSortRec(head)
}

// 获取中间节点
// - 如果链表长度为奇数，则返回中间节点
// - 如果链表长度为偶数，则有两个中间节点，这里返回第一个
let middleNode = function(head) {
    let fast = head, slow = head
    while(fast && fast.next && fast.next.next) {
        slow = slow.next
        fast = fast.next.next
    }
    return slow
}

// 归并排序
// 若分裂后的两个链表长度不为 1，则继续分裂
// 直到分裂后的链表长度都为 1，
// 然后合并小链表
let mergeSortRec = function (head) {
    if(!head || !head.next) {
        return head
    }

    // 获取中间节点
    let middle = middleNode(head)
    // 分裂成两个链表
    let temp = middle.next
    middle.next = null
    let left = head, right = temp
    // 继续分裂（递归分裂）
    left = mergeSortRec(left)
    right = mergeSortRec(right)
    // 合并两个有序链表
    return mergeTwoLists(left, right)
}

// 合并两个有序链表
let mergeTwoLists = function(l1, l2) {
    let preHead = new ListNode(-1);
    let cur = preHead;
    while(l1 && l2){
        if(l1.val < l2.val){
            cur.next = l1;
            l1 = l1.next;
        }else{
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    cur.next = l1 || l2;
    return preHead.next;
}
```

## 查找

线性表中：

- 顺序查找
- 二分查找
- 分块查找

树表中：

- 二叉排序树

散列表中：

- 哈希表

### 二分查找

```js
// 实现二分查找
// 输入：有序数组，key值
// 输出：key值对应的索引
const BinarySearch = function (nums, key, left, right) {
  if (left > right) return null;
  let mid = (left + right) >> 1;
  let midVal = nums[mid];
  if (midVal < key) {
    // 目标值在右侧，则将将左边界置为 mid+1
    return BinarySearch(nums, key, mid + 1, right);
  } else if (midVal > key) {
    return BinarySearch(nums, key, left, mid - 1);
  } else {
    return mid;
  }
};

// 不使用递归，直接更新left和right即可。
const _BinarySearch = function (nums, key, left, right) {
  if (left > right) return null;
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (nums[mid] > key) {
      right = mid - 1;
    } else if (nums[mid] < key) {
      left = mid + 1;
    } else {
      return mid;
    }
  }
};
```

### 二分排序树查找

```js
const BST_search = (node, target) =>{
  if(node){
    if(node.val == target){
      return true;
    }else if(node.val < target){
      BST_search(node.right, target);
    }else{
      BST_search(node.left, target);
    }
  }
  return false;
}
```

## 树

2021.11.29算法笔记

### 剑指 Offer 27. 二叉树的镜像 / 翻转二叉树

请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入：
     4
   /   \
  2    7
 / \   / \
1 3 6  9
镜像输出：
     4
   /   \
  7    2
 / \   / \
9 6  3 1
示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

**自己的思路：**
使用递归思路来解决即可

**方法一：实现递归**
解题代码：

```jsx
/**

 * Definition for a binary tree node.
 * function TreeNode(val) {
 *   this.val = val;
 *   this.left = this.right = null;
 * }
*/

/**
 * @param {TreeNode} root
 * @return {TreeNode}
*/
var mirrorTree = function (root) {
  // 应该使用递归的思路来解决，或者遍历的思路。
  if (root!=null) {
    //这种数组的方式来置换的确是没想啊
    [root.left, root.right] = [root.right, root.left];//es6的解构赋值！
    mirrorTree(root.left);
    mirrorTree(root.right);
  }
  //对root的子节点操作，返回root就行了。
  return root
};
```

**方法二：使用辅助栈（或者队列）**

- 利用栈（或队列）遍历树的所有节点 nodenode ，并交换每个 nodenode 的左 / 右子节点。

2021.12.21 算法笔记

### 剑指 Offer 55 - I. 二叉树的深度

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
    3
   / \
 9  20
     /  \
  15   7
返回它的最大深度 3 。
提示：节点总数 <= 10000

**自己的思路**：
使用递归的思路，找出最深的叶节点。

代码实现：

```jsx
/**

 * Definition for a binary tree node.
 * function TreeNode(val) {
 * this.val = val;
 * this.left = this.right = null;
 * }
   */
   /**
 * @param {TreeNode} root
 * @return {number}
   */
   var maxDepth = function(root) {
   if(root.left !=null  root.right != null){
       number ++
   }
   let number_left = maxDepth(root.left, number);
   let number_right = maxDepth(root.right,number);
   if(number_left >= number_right){
       number = number_left;
   }else{
       number = number_right;
   }
   return number;
   };
   //代码烂的一，想的过于复杂。
   修改之后：
   var maxDepth = function(root) {
   if(!root) return 0;
   return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
   }; //这是后序遍历的递归实现
```

**方法二：基于回溯思想的先序遍历**

```jsx
var maxDepth = function(root) {
  let deep = 0, max = 0;
  dfs(root);
  return max;

  function dfs(root){
    if(!root) return;
    deep++;
    if(deep > max) max = deep;
    dfs(root.left);
    dfs(root.right);
    //回溯
    deep--;
  }
};
```

2022.03.10 算法笔记

### 剑指 Offer 54. 二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第 k 大的节点的值。

示例 1:
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4

限制：
1 ≤ k ≤ 二叉搜索树元素个数

**自己思路：**
先遍历整棵树，存储，再排序，再选择输出。

`//错误！本来就是二叉搜索树，左子树<根节点<右子树`

故而使用中序遍历即可，输入两个参数（root,k），第K个数返回即可。

代码展示：

```jsx
/**

 * Definition for a binary tree node.
 * function TreeNode(val) {
 * this.val = val;
 * this.left = this.right = null;
 * }
   */
    /**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
   */
var kthLargest = function (root, k) {
   // 本来就是二叉搜索树，左子树是小于根节点的，右子树大于根节点。
   const arr = [];
   const dfs = (root) => {
       if (root) {
           dfs(root.right);
           // root.val的是根节点的值，null也含在内。
           arr.push(root.val);
           dfs(root.left);
       }
   }
   dfs(root);
   return arr[k - 1]
};
```

### 剑指 Offer 28. 对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

​  1
   /  \
  2     2
 / \   / \
3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

​ 1
   / \
  2   2
   \    \
​    3    3

**示例 1：**

输入：root = [1,2,2,3,4,4,3]
输出：true

**使用递归**，但写递归写错了，需要抽离出来使用递归的部分是什么呢？是左右节点作为输入，比较左右节点的孩子节点是否符合对称二叉树的特点。

```jsx
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    // 非完全二叉树一定是不对称的
    // 遍历左右孩子节点,如果都满足对称二叉树,则整体是完全二叉树。
    // 比较左孩子节点的左孩子和右孩子结点的右孩子……
    // 故而,使用递归。
    if (root == null) return true;
    const Symmetric = function (nodeLeft, nodeRight) {
        if ((nodeLeft == null) && (nodeRight == null)) return true;
        if ((nodeLeft == null) || (nodeRight == null)) return false; // 包含了上一句的情况
        return nodeLeft.val === nodeRight.val && Symmetric(nodeLeft.left, nodeRight.right) && Symmetric(nodeLeft.right, nodeRight.left);
    }
    return Symmetric(root.left, root.right);

};
```

### 100、相同的树

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例1：

输入：p = [1,2], q = [1,null,2]
输出：false

示例2：

输入：p = [1,2,3], q = [1,2,3]
输出：true

**自己思路**：

在树形结构上，对于节点操作，率先考虑递归。

```jsx
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {
    // 使用递归的写法.抽离出p,q节点的子树比对过程。
    // 如果两个节点都是空节点 则肯定相同  如果两个节点只有一个节点为空
    if (p == null || q == null) return p == q;
    // 两个节点的值是否相同，只有相同才去递归比较左右子树。
    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
};
```

### 94、二叉树的中序遍历

**思路**：

使用递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    const num = [];
    // 递归思想
    function inorder(root) {
        if (!root) {
            return;
        }
        inorder(root.left);
        num.push(root.val);
        inorder(root.right);
    }
    inorder(root);
    return num;
};
```

### 剑指 Offer 55 - II. 平衡二叉树

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

​ 3
   / \
  9  20
​    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

   1
  / \
 2   2
/ \
   3   3
  / \
 4   4
返回 false 。

**题解**：

使用递归的思路，比较每个节点的左右子树的深度，当节点为空的时候，就返回其深度。
所以递归算法的入参需要当前节点和当前深度。
所以每次递归度需要在深度的参数位置上+1.
若根节点的左右子树的差值大于1，就false；否则，true。

```js
//  换一种定义二叉树的方式
// class TreeNode {
//     constructor(value) {
//         this.val = value;
//         this.left = this.right = null;
//     }
// }
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
    let res = true;
    // 判断是否是平衡二叉树，入参分别是当前节点和当前深度
    const treeDeep = function (root, deep) {
        if (!root) {
            return deep;
        } else {
            let leftDeep = treeDeep(root.left, deep + 1);
            let rightDeep = treeDeep(root.right, deep + 1);
            if (Math.abs(leftDeep - rightDeep) > 1) {
                res = false;
            }
            return Math.max(leftDeep, rightDeep);
        }
    };
    // 执行递归算法
    treeDeep(root, 0);
    return res
};
```

### 104、二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    // 递归写法，合理使用闭包。
    const truedeep = function (node, deep) {
        if (!node) return deep;
        let leftdeep = truedeep(node.left, deep + 1);
        let rightdeep = truedeep(node.right, deep + 1);
        if (leftdeep > rightdeep) {
            return leftdeep;
        } else {
            return rightdeep;
        }
    }
    return truedeep(root, 0);
};
```

### 543、二叉树的直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :

给定二叉树

​      1
​     / \
​    2   3
   / \
  4   5

返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示

**思路**：

最大深度是指这棵树所有节点的最大深度，需要设置一个max，递归的时候不断更新。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function (root) {
    // 需要不断更新子树中的最大深度
    let deep = 0;
    const countDeep = (root) => {
        if (!root) {
            return 0;
        }
        let leftdeep = countDeep(root.left);
        let rightdeep = countDeep(root.right);
        deep = leftdeep + rightdeep < deep ? deep : leftdeep + rightdeep;
        return Math.max(leftdeep, rightdeep) + 1;
    }
    // 理解题意可知，二叉树直径为左右子树的的最大高度之和。
    countDeep(root);
    return deep;
};
```

### 剑指 Offer 32 - II. 从上到下打印二叉树 II

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:
给定二叉树: [3,9,20,null,null,15,7],

​ 3
   / \
  9  20
​    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

**自己思路**：

这是经典的**层次遍历**，但返回的是二维数组，如何创建和对其push以及pop呢？ push. 和. shift.

```js
const levelOrder = (root) => {
  if (!root) {
    return [];
  }
  const res = [],queue = [];
  queue.push(root);
  while (queue.length > 0) {
    let curLength = queue.length;
    const tmp = [];
    for (let i = 0; i < curLength; i++) {
      let node = queue.shift();
      tmp.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    res.push(tmp);
  }
  return res;
};
```

### 二叉树的右视图

[[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/)]

```js
// 层次遍历 | 二叉树的右视图
const rightSideView = (root) => {
  if (!root) {
    return [];
  }
  const res = [], // 结果数组
    queue = []; // 每一层的队列
  queue.push(root);
  while (queue.length > 0) {
    const tmp = []; // 存放每一层节点的值
    let curLength = queue.length;
    for (let i = 0; i < curLength; i++) {
      let node = queue.shift();
      tmp.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    res.push(tmp[tmp.length-1]);   // 此处即‘右视图’，'左视图'：res.push(tmp[0])
  }
  return res;
};

console.log('二叉树的右视图：', rightSideView(root));
```

### 蛇形打印二叉树

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

```js
var levelOrder = function (root) {
    // 辅助栈
    // 比第二版多了一个层次输出
    if (!root) return [];
    const res = [], queue = [];
    queue.push(root);
    let level = true;
    while (queue.length !== 0) {
        let curSize = queue.length;
        res.push([]);
        for (let i = 1; i <= curSize; i++) {
            let node = queue.shift();
            if (level) {
                res[res.length - 1].push(node.val);
            } else {
                res[res.length - 1].unshift(node.val);
            }
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        level = !level;
    }
    return res;
};
```

### 二叉树的最近公共祖先

[剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```js
// 分为三种情况
// 1. root == null 直接返回
// 2. p q之中任一者等于root的值
// 3. 递归处理：如果都没找到p和q，返回null。
const lowestCommonAncestor = function (root, p, q) {
    if (!root) {
        return null;
    }
    if (root.val == p.val || root.val == q.val) {
        return root;
    }
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    if (left && right) return root;
    if (left == null && right == null) return null;
    return left == null ? right : left;
};
```

### 路径总和  ||

[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/)

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

```js
// 深度优先遍历的进一步变体 
const pathSum = (root, targetSum) => {
    const res = [], path = [];    // 结果数组res  单次的路径数组path
    const dfs = (root, targetSum) => {
        if (!root) {
            return;
        }
        path.push(root.val);
        targetSum -= root.val;
        if(targetSum === 0 && root.left == null && root.right == null){
            res.push([...path]);   // 存放的是path中的数组，而不是存引用类型的地址。
        }
        dfs(root.left,targetSum);
        dfs(root.right,targetSum);
        path.pop();
    };
    dfs(root,targetSum);
    return res;
};
```

### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

题解思路：递归函数携带（上一次递归的结果作为）入参。

````js
const sumNumbers = function (root) {
    // 构建 递归 携带参数
    // 深度遍历
    const sumTree = (root, preNum) => {
        if (root == null) {
            return 0;
        }
        let sum = preNum * 10 + root.val;
        if (root.left == null && root.right == null) {
            return sum;
        } else {
            return sumTree(root.left, sum) + sumTree(root.right, sum);
        }
    };
    return sumTree(root, 0);
};
````

## 链表

### 21、合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

![img](算法刷题 剑指offer第二版.assets/merge_ex1.jpg)

输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

**自己思路**：

新建头结点，使用哨兵比较，之后再接入。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
    let pre = new ListNode(0);
    // 设置一个哨兵
    let p = pre;
    // 循环边界是两者都不为空
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            p.next = list1;
            list1 = list1.next;
        } else {
            p.next = list2;
            list2 = list2.next;
        }
        p = p.next;
    }
    // 循环结束之后有两种情况需要考虑
    p.next = (list2 == null) ? list1 : list2;
    return pre.next;
};
```

2021.11.28算法笔记

### 剑指 Offer 22. 链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

示例：
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
即输入[1,2,3,4,5] 2，输出[4,5]

**自己思路：**
是一个数组截取的思路
将输入的数组，倒数K个放入另一个数组即可；或者将前面K-1个删除即可；

// 错误！

代码如下;

```jsx
/**

 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
   */
    var getKthFromEnd = function(head, k) {
   let length = head.length
   var array = []
   let i=k
   for(i=k;i--;i>0){
       array.push(head[length-i])
   }
   return array
    };
    //出错！typeerror!
    因为head是ListNode，不是数组，不能使用push方法来追加新的元素。
```

**解题思路**

 n可以理解为快指针和慢指针的间隔
 当快指针走到最后，则慢指针就是走到倒数第k个节点

代码：

```jsx
var getKthFromEnd = function(head, k) {
    let fast = head, low = head, n = 0;
    // 当快指针跑完的时候，慢指针刚好指向倒数第k个。
    while (fast) {
        fast = fast.next;
        if (n >= k) {
            low = low.next;
        }
        n++;
    }
    return low;
};
```

**补充：`NodeList`对象**

是`DOM`操作取出的集合（实际上是基于`DOM`结构动态查询的结果），用来保存一组有序的节点，可以通过位置来访问这些节点，它并不是`array`的实例。
`NodeList`最大的特点就是它的时效性，`DOM`结构的变化能自动反映在`NodeList`对象中。也就是说当`DOM`结构发生变化时，`NodeList`立刻会发生变化。

### 剑指 Offer 35. 复杂链表的复制

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]

示例 4:

输入：head = [ ]
输出：[ ]
解释：给定的链表为空（空指针），因此返回 null。

**自己思路：**

遍历复制的话，无法构建 `random`引用指向，不会写啊

**学习题解思路：**

使用哈希表的键值对来存储原链表和新链表的`节点`对应，即（键：值）=>（原节点：新节点）。

````jsx
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function (head) {
  // 非空判定
  if (!head) return head;
  let node = head;
  // 把所有节点都存到map中
  let map = new Map();
  // 复制节点，将新节点放入map中
  while (node) {
    map.set(node, new Node(node.val));
    node = node.next;
  }
  // 再将当前指针指向头节点
  node = head;
  // 从头节点再开始遍历，更改map中对应节点的next指针和random指针
  while (node) {
    map.get(node).next = map.get(node.next) || null;
    map.get(node).random = map.get(node.random);
    node = node.next;
  }
  // 返回map中的头节点，也就是复制后的头节点
  return map.get(head);
};
````

### 剑指 Offer 06. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

输入：head = [1,3,2]
输出：[2,3,1]

限制：0 <= 链表长度 <= 10000；

**自己思路**：

遍历放到数组中，调用`reserve`方法即可。// 直接A出来，击败77%。

```jsx
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {number[]}
 */
var reversePrint = function(head) {
    let array = new Array();
    while(head){
        array.push(head.val);
        head = head.next;
    }
    return array.reverse();
};
```

### 剑指 Offer 52. 两个链表的第一个公共节点

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表**：**

[![img](算法刷题 剑指offer第二版.assets/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

示例 1：

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3

输出：Reference of the node with value = 8

输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

**自己思路：**

先使用暴力法：双重遍历

**题解思路：**

存在哈希表中，直接调用`map.has(key)`来寻找，时间复杂度为`O(m+n)`。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
    // let A = headA, B = headB;
    // while (A !== B) {
    //     A = A === null ? headB : A.next;
    //     B = B === null ? headA : B.next;
    // }

    // 将链表A的节点装入map中，B遍历比较即可，有则返回；
    let map = new Map();
    while (headA) {
        map.set(headA);
        headA = headA.next;
    }
    while (headB) {
        if (map.has(headB)) {
            return headB
        }
        headB = headB.next;
    }
    return null;
};
```

### 剑指 Offer 18. 删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

示例 1:

输入: head = [4,5,1,9], val = 5

输出: [4,1,9]

解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

**自己思路**：

先找到需要删除的节点，指针跳过该指针即可，返回head。

// 需要仔细理清楚链表的操作逻辑

```jsx
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var deleteNode = function (head, val) {
    let newHead = new ListNode(0);
    newHead.next = head;
    let node = newHead;
    while (node && node.next) {
        if (node.next.val == val) {
            node.next = node.next.next;
        }
        node = node.next;
    }
    return newHead.next;
};
```

**题解**：使用递归的方法

```jsx
var deleteNode = function (head, val) {
    // 在比对val的过程中使用递归
    if (head.val == val) {
        return head.next;
    }
    head.next = deleteNode(head.next, val);
    return head;
};
```

### 剑指 Offer 24. 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

**自己思路**：

使用数组来存放 // 不大可行，需要定義多個指针来使用。

```jsx
var reverseList = function(head) {
    let pre = null,cur = head;
    let temp;
    while(cur){
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
};
```

故而**使用解构赋值**：

```jsx
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
    // 使用解构赋值
    let [p, h] = [null, head];
    while (h) {
        [h.next, p, h] = [p, h, h.next];
    }
    return p;
};
```

### 部分翻转链表

![2e8c566e275642e692c1feb98bf80550](算法刷题记录.assets/2e8c566e275642e692c1feb98bf80550-9105888.png)

```js
// head是链表，left是翻转部分的左边界，right是右边界。
function reverseBetween(head, left, right) {
    if(left==1){
        return reverseN(head,right);
    }
    head.next=reverseBetween(head.next,left-1,right-1);
    return head;
};
let successor=null;
function reverseN(head,n){
    if(n==1){
        successor=head.next;
        return head;
    }
    let last=reverseN(head.next,n-1);
    head.next.next=head;
    head.next=successor;
    return last;
    
}
```

### 剑指 Offer 25. 合并两个排序的链表

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

示例1：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

**自己思路**：

使用解构赋值，或者创建新的链表在赋值。

```jsx
// Definition for singly-linked list.
// function ListNode(val) {
//     this.val = val;
//     this.next = null;
// }
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function (l1, l2) {
    let cur = node = new ListNode(0);
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            [cur.next, l1] = [l1, l1.next];
        }
        else {
            [cur.next, l2] = [l2, l2.next];
        }
        cur = cur.next;
    }
    cur.next = l1 != null ? l1 : l2;
    return node.next;
};
```

**官方题解**：

抽离出比较并`next`的步骤，使用**递归**来操作。

```jsx
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) {
        return l2;
    } 
    else if (l2 === null) {
        return l1;
    } 
    // 递归！！
    else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
};
```

### 141、环形链表

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

示例 1：

![img](算法刷题 剑指offer第二版.assets/circularlinkedlist.png)

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

**自己思路**：

使用哈希表

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
    let map = new Map();
    let start = head;
    while(start){
        if(map.has(start)){
            return true;
        }else{
            map.set(start);
            start = start.next;
        }
    }
    return false;
};
```

## 力扣

2021.11.23算法笔记

### 剑指 Offer 58 - II. 左旋转字符串

示例 1：
输入: s = "abcdefg", k = 2
输出: "cdefgab"
即左旋两位得到结果

**自己思路:**
使用字符串切片的功能来实现即可

伪代码:

```jsx
var reverseLeft = function (s, n) {
  return s[n:]+s[: n]
}
```

错误! js的字符串的自带方法中没有切片属性!（数组方法中使用`slice`可切片返回新数组。）
[需要仔细研读js基本类型的自带方法!!!]

#### JS中string对象的方法：substring()

string对象的`substring`()方法，提取字符串中两个指定的索引号之间的字符。
`substring(from,to)`  // `from`是起始位置(从`1`开始算,不包括`from`位置本身,包含`to`本身,`to`位置为最后一个字符)
所以修改代码为

```jsx
var reverseLeft = function(s,n){
 let length = s.length;
 return s.substring(n,length)+s.substring(0,n);
}
//答案正确
```

2021.11.24算法笔记

### 剑指 Offer 64 - II. 求1+2+…+n

求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
示例 1：
输入: n = 3
输出: 6

**自己思路：**
使用递归思路来解决？不会写伪代码

```jsx
var sumNums = function(n) {
 return n && sumNums(n-1) + n;
};
//答案正确！
```

#### 知识回忆：逻辑短路

逻辑短路是对于逻辑运算而言，是指，仅计算逻辑表达式中的一部分便能确定结果，而不对整个表达式进行计算的现象。
对于“`&&`”运算符，当第一个操作数为`false`时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是`false`；
对于“`||`”运算符，当第一个操作数为`true`时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是`true`。

### 剑指 Offer 56 - II. 数组中数字出现的次数

在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
示例 1：
输入：nums = [3,4,3,3]
输出：4

**自己思路：**
可去循环判断该数字是否有重复，如果没有重复，那就跳出，找到该数字；

伪代码

```jsx
const singleNumber = (nums) => {
    let length = nums.length;
    let count = 0;
    for (var i = 0; i++; i < length) {
        for (let j = 0; j++; j < legth) {
            if (nums[i] == nums[j]) {
                count++
            }
        }
        if (count == 1) {
            return nums[i]
        } else {
            count = 0
        }
    }
};
```

// 错误！
输入 [3,4,3,3]
输出 undefined

**解题思路：**

#### 1、考虑位运算和+有限状态自动机

考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是3的倍数。
因此，统计所有数字的各二进制位中1的出现次数，并对 3 求余，结果则为只出现一次的数字。

```jsx
/**
  * @param {number[]} nums
  * @return {number}
  */
   var singleNumber = function(nums) {
   let res = 0;
   for (let i = 0; i < 32; i++) {
       // 对于int每一位
       let bit = 0;
       // 计算该位上的和
       for (let num of nums) {
           bit += ((num >> i) & 1);
       }
       // 对3取余即为res在该位的值
       res += ((bit % 3) << i);
   }
   return res;
   };
```

题解链接:

<https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/>

#### 2、双层遍历统计

```jsx
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
  let length = nums.length;
  // let count = 0;
  flag = true;
  for (var i = 0; i < length; i++) {
    for (let j = 0; j < length; j++) {
      if (nums[i] === nums[j] && i != j) {
        flag = false;
        break;
      }//如果不满足该条件，那自然就是答案了
    }
    if (flag) {
      return nums[i]
    } else {
      flag = true;
    }
  }
};
   //答案正确！虽然笨了点
```

### 剑指 Offer 17. 打印从1到最大的n位数

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999

示例 1:
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]

说明：
用返回一个整数列表来代替打印
n 为正整数

**自己思路：**
使用num累乘和while循环打印即可

代码如下：

````jsx
/**
 * @param {number} n
 * @return {number[]}
 */
const printNumbers = (n) => {
  // n 为输入的位数
  let num=0;
  for(let i = 1;i<=n;i++){
    num = num*10;
  }
  // 使用整数列表来代替打印
  let arr = [];
  let j = 1;
  while(j<num){
    arr.push(j);
    j++;
  }
  return arr;
};
````

// 求解正确，但内存占用过多。

2022.03.14 算法笔记

### 剑指 Offer 05. 替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：
输入：s = "We are happy."
输出："We%20are%20happy."

限制：0 <= s 的长度 <= 10000

代码展示：

````jsx
/**
 * @param {string} s
 * @return {string}
 */
var replaceSpace = function (s) {
  // 将字符串转化为数组再转化为字符串
  // split(" ")是根据存在的空格来切分字符串为不同的子字符串，使其为数组中的不同项
  let arr = s.split(" ");
  let len = arr.length;
  let t = arr[0];
  // 此处观察问题的输出答案，将首个拼接的字符串置为第一个数组，注意顺序。
  for (let i = 1; i < len; i++) {
    t = t + "%20" + arr[i];
  }
  return t;
};
````

### 剑指 Offer 10- I. 斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

输入：n = 2
输出：1

**自己思路：**

使用递归解决：`return fib(n-1)+fib(n-2);`

非递归的斐波那契算法

```jsx
/**
 * @param {number} n
 * @return {number}
 */
// //  递归的写法 （还需要考虑溢出）
// var fib = function(n) {
//     if(n<2){return n}
//     return fib(n-1)+fib(n-2);
// };
const fib = function (n) {
    const constNum = 1000000007;
    let first = 0;
    let second = 1;
    while (n-- > 0) {
      let temp = first + second;
      first = second % constNum;
      second = temp % constNum;
    }
    return first;
}
```

### 剑指 Offer 03. 数组中重复的数字

找出数组中重复的数字。

在一个长度为 `n` 的数组 `nums` 里的所有数字都在 `0～n-1` 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]

输出：2 或 3
限制：2 <= n <= 100000

**自己思路**：

用`Set`先给数组去重，在使用去重数组计数遍历，count>1就抛出来。

`// A出来了，但耗时耗内存！`击败百分之五！

改进：往哈希表（`Set`）中填充，如果不同，原数组的那个数字就是重复的。// 击败百分之五十！

```jsx
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function(nums) {
    // 去重数组Setnums
    let Setnums = [...new Set(nums)];
    // 再逐一比较
    for(let i=0;i<nums.length;i++){
        if(nums[i]!=Setnums[i]){
            return nums[i];
        }
    }
};
```

### 1、两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 2：**

输入：nums = [3,2,4], target = 6
输出：[1,2]

提示：

- 2 <= nums.length <= 104
- -109 <= nums[i] <= 109
- -109 <= target <= 109
- 只会存在一个有效答案

**自己思路**：

使用`findIndex`方法来解决

// 失败！

**题解**：

使用`map`的`has`和`get`方法

```jsx
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
    let map = new Map();
    for (let i = 0; i < nums.length; i++) {
        if (map.has(target - nums[i])) {
            return [map.get(target - nums[i]), i];
        }
        else {
            map.set(nums[i], i);
        }
    }
};
```

### 剑指 Offer 04. 二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。

给定 target = 20，返回 false。

限制：0 <= n <= 1000; 0 <= m <= 1000;

**自己思路**：

给数组降维，调用`find`或者`findindex`即可；//`flat([2])` 和`findIndex`

```jsx
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var findNumberIn2DArray = function (matrix, target) {
    let nums = matrix.flat([3]);
    let flag = nums.findIndex((item) => item == target);
    if (flag != -1) {
        return true;
    } else {
        return false;
    }
};
```

**题解**：

使用二分查找法（对每一行使用二分查找）

### 剑指 Offer 58 - I. 翻转单词顺序

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

示例 1：

输入: "the sky is blue"
输出: "blue is sky the"

说明：

无空格字符构成一个单词。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

**自己思路**：

观察结构，也就是空格的出现使得一个句子分成了多个单词。使用JS原生的String方法的`split`就可实现分割并返回数组。

然后翻转数组，再转为字符串即可。// 呆瓜方法，才击败百分之四十！

// `join`方法的使用和`trim`方法的使用还需要加强。

```jsx
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function (s) {
    let sArray = s.split(' ');
    sArray = sArray.reverse();
    s = sArray.join('#');
    while (s.includes('#')) {
        s = s.replace('#', ' ');

    }
    while (s.includes('  ')) {
        s = s.replace('  ', ' ');
    }
    return s.trim();
};
```

**官方题解**：

还使用了正则表达式，装了我一手…

**\s表示：**匹配任何空白字符，包括空格、制表符、换页符等等。等价于`[ \f\n\r\t\v]`。
**+表示：**匹配前面的子表达式一次或多次。

```jsx
var reverseWords = function(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
};
```

### 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4]

注：[3,1,2,4] 也是正确的答案之一。

提示：0 <= nums.length <= 50000；0 <= nums[i] <= 10000；

**自己思路**：

使用`filter`函数即可，配合`concat`函数！

```jsx
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var exchange = function (nums) {
    let oneNums = nums.filter((item) => item % 2 == 1);
    let twoNums = nums.filter((item) => item % 2 == 0);
    return oneNums.concat(twoNums);
};
```

**题解方法**：只遍历一次就完成了

使用`push`将偶数添加到末尾，使用`unshift`将奇数添加到开头。

```jsx
var exchange = function(nums) {
  const res = []
  for(const num of nums) {
    // 偶数的话，push()
    if(num % 2 == 0) {
      res.push(num)
    } else {
    // 奇数的话unshift()
    res.unshift(num)
    }
  }
  return res
};
```

### 剑指 Offer 10- II. 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

输入：n = 2
输出：2

示例 2：

输入：n = 7
输出：21

**自己思路**：

考虑到青蛙每次只能跳一层或两层台阶，使用递归即可完成。

**题解方法**：

1. 递归+记忆（IIFE、闭包）
2. 动态规划
3. 滑动数组

```jsx
// 递归+记忆
const numWays = (() => {
  const memo = {};
  return (n) => {
    if (n === 0 || n === 1) return 1;
    if (!memo[n - 1]) memo[n - 1] = numWays(n - 1);
    if (!memo[n - 2]) memo[n - 2] = numWays(n - 2);
    return (memo[n - 1] + memo[n - 2]) % 1000000007;
  };
})();
```

```jsx
// 动态规划
// 
var numWays = function(n) {
    let dp = [1, 1];
    for (let i = 2; i <= n; i++) {
        dp.push(dp[i - 1] + dp[i - 2]);
    }
    return dp[n];
};
```

```jsx
// 滑动数组
// 迭代的思想
var numWays = function(n) {
    // 第 i 级台阶，可以从 i-1 跳 1步，或 i-2 跳 2 步
    // dp[i] = dp[i-1] + dp[i-2];
    // dp[0] = 1; dp[1] = 1; 
    let dp = [1,1];
    if(n < 2) return 1;
    for(let i = 2; i <= n; i++) {
        let types = (dp[0] + dp[1]) % 1000000007;
        dp[0] = dp[1];
        dp[1] = types;
    }
    return dp[1];
};
```

### 剑指 Offer 09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]

**自己思路**：

我是呆瓜，题目都没看懂。两个栈来实现队列的话，一个只输入，一个只输出，就实现先进先出的队列了。

**大神题解**：

题目只要求实现 加入队尾`appendTail`() 和 删除队首`deleteHead`() 两个函数的正常工作，因此我们可以设计栈 `A` 用于加入队尾操作，栈 `B` 用于将元素倒序，从而实现删除队首元素。

加入队尾 `appendTail`()函数： 将数字 val 加入栈 A 即可。

删除队首`deleteHead`()函数： 有以下三种情况。

1. 当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。
2. 否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1 。
3. 否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。

```python
class CQueue:
    def __init__(self):
        self.A, self.B = [], []

    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B: return self.B.pop()
        if not self.A: return -1
        while self.A:
            self.B.append(self.A.pop())
        return self.B.pop()
```

改写为`JS`：

```jsx
var CQueue = function () {
    this.A = [];
    this.B = [];
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function (value) {
    this.A.push(value);
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function () {
    if (this.B.length) return this.B.pop();
    if (!this.A.length) return -1;
    while (this.A.length) {
        this.B.push(this.A.pop());
    }
    return this.B.pop();
};

/**
 * Your CQueue object will be instantiated and called as such:
 * var obj = new CQueue()
 * obj.appendTail(value)
 * var param_2 = obj.deleteHead()
 */
```

题目难懂，但之后更理解内部方法和构造函数的原理了！

### 剑指 Offer 11. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

示例 1：

输入：numbers = [3,4,5,1,2]
输出：1

示例 2：

输入：numbers = [2,2,2,0,1]
输出：0

提示：

n == numbers.length
1 <= n <= 5000
-5000 <= numbers[i] <= 5000
numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

**自己思路**：

找到旋转的最小元素，考虑到原本是升序的数组，需要比对前后大小将后者小于前者的取出来，与后面的结果作比较。

```jsx
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function (numbers) {
    let minNum = numbers[0];
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] > numbers[i + 1]) {
            if (minNum > numbers[i + 1]) {
                minNum = numbers[i + 1];
            }

        }
    }
    return minNum;
};
```

**官方题解**：

考察的是查找的效率，使用二分查找。`部分有序+查找，符合二分法的使用场景，能提高效率。`

```jsx
var minArray = function(numbers) {
    let low = 0;
    let high = numbers.length - 1;
    while (low < high) {
        const pivot = low + Math.floor((high - low) / 2);
        if (numbers[pivot] < numbers[high]) {
            high = pivot;
        } else if (numbers[pivot] > numbers[high]) {
            low = pivot + 1;
        } else {
            high -= 1;
        }
    }
    return numbers[low];
};
```

### 剑指 Offer 15. 二进制中1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

示例 1：

输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

**自己思路**：

转化为字符串，遍历查找，计数即可。// 击败70%！

```jsx
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function (n) {
    // toString(2)将二进制转化为字符串
    let n_s = n.toString(2);
    let n_num = 0;
    for (let i = 0; i < n_s.length; i++) {
        if (n_s[i] == 1) {
            n_num++;
        }
    }
    return n_num;
};
```

**官方题解**：

使用位运算

**思路及解法**

我们可以直接循环检查给定整数`n`的二进制位的每一位是否为`1`。

具体代码中，当检查第`i`位时，我们可以让`n`与 `2^i`进行与运算，当且仅当`n`的第`i`位为`1`时，运算结果不为`0`。

```jsx
var hammingWeight = function(n) {
    let ret = 0;
    for (let i = 0; i < 32; i++) {
        // 使用位运算
        if ((n & (1 << i)) !== 0) {
            ret++;
        }
    }
    return ret;
};
```

### 剑指 Offer 29. 顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

示例 1：

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

**自己思路**：

层次遍历？不会写。

**题解**：

1. 选择一次迭代遍历一个“圈”，然后 4 条边的两端同时收缩，一层层向内处理，按顺时针依次遍历：上、右、下、左层。
2. 不再形成“环”了就结束遍历，剩下一行或一列，然后单独判断即可。

- 上边界 top : 0
- 下边界 bottom : matrix.length - 1
- 左边界 left : 0
- 右边界 right : matrix[0].length - 1

`top < bottom && left < right` 是循环的条件。结束循环时，分 3 种情况：

1. top == bottom && left < right —— 剩一行。
2. top < bottom && left == right —— 剩一列。
3. top == bottom && left == right —— 剩一项（也是一行/列）。

```jsx
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function (matrix) {
    // 先做判断
    if (!matrix.length) return [];
    let top = 0;
    let bottom = matrix.length - 1;
    let left = 0
    let right = matrix[0].length - 1;
    // 设置返回的数组
    let res = [];
    while (top < bottom && left < right) {
        for (let i = left; i < right; i++) { res.push(matrix[top][i]) }
        for (let i = top; i < bottom; i++) { res.push(matrix[i][right]) }
        for (let i = right; i > left; i--) { res.push(matrix[bottom][i]) }
        for (let i = bottom; i > top; i--) { res.push(matrix[i][left]) }
        right--;
        bottom--;
        left++;
        top++;
    }
    if (top == bottom) {
        for (let i = left; i <= right; i++) {
            res.push(matrix[top][i]);
        }
    }else if (left == right) {
        for (let i = top; i <= bottom; i++) {
            res.push(matrix[i][left]);
        }
    }
    return res;
};
```

### 剑指 Offer 30. 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

示例:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.

提示：

各函数的调用总次数不超过 20000 次

**题解**：

```jsx
/**
 * initialize your data structure here.
 */
var MinStack = function () {
    this.stack = [];
    this.min_stack = [Infinity];
    // 设置辅助栈，需要设置一个极大值，方便取到自身。
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function (x) {
    this.stack.push(x);
    this.min_stack.push(Math.min(this.min_stack[this.stack.length - 1], x))
    // 相当于min_stack的最上面一直是最小的值
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {
    this.stack.pop();
    this.min_stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function () {
    return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.min = function () {
    return this.min_stack[this.min_stack.length - 1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.min()
 */
```

### 剑指 Offer 42. 最大子数组和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

**示例1:**

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

**题解**：

```jsx
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
    let res = nums[0];
    for (let i = 1; i < nums.length; i++) {
        nums[i] = nums[i] + Math.max(nums[i - 1], 0);
        res = Math.max(res, nums[i]);
    }
    return res;
};
```

### 剑指 Offer 53 - II. 0～n-1中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

**示例 1:**

输入: [0,1,3]
输出: 2

**自己思路**：

不缺该数字时的总和减去现在的总和，就是缺失的数字了。使用`reduce`实现数组累加求和：`reduce((sum.cur)=>sum+cur,0)`

```jsx
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
    let sum = 0;
    for (let i = 0; i <= nums.length; i++) {
        sum += i;
    }
    return sum - nums.reduce((sum, cur) => sum + cur, 0);
};
```

**题解思路**：

- `排序数组中的搜索问题`，首先想到 **二分法** 解决。（经典的使用**异或**运算符解决！）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
  let left = 0,
    right = nums.length - 1;
  // 左闭右闭区间
  while (left <= right) {
    let mid = left + ((right - left) >> 1); // 此处是右移一位，位运算相当于除以2.
    /* 把整个数组看成
    左子数组： nums[i] = i
    右子数组： nums[i] != i */
    // 当中间元素跟索引相等，那就应该去右子数组中查找
    if (nums[mid] == mid) left = mid + 1;
    // 如果不等的话，就去找左子数组中查找，因为我们本质上是要找不相等的第1个（或者说最左边的那个）
    else right = mid - 1;
  }
  return left;
};
```

### 剑指 Offer 53 - I. 在排序数组中查找数字

统计一个数字在排序数组中出现的次数。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0

**自己思路**：

使用`findIndex`函数来找出第一个符合条件的索引，随后开始`while`判断并进行`conut`累加。// 击败80.17%！

```jsx
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
    // 使用findIndex函数
    let index;
    if (nums.findIndex((item) => item == target) == -1) {
        return 0;
    }
    else if (nums.findIndex((item) => item == target) != -1) {
        index = nums.findIndex((item) => item == target);
        let count = 0;
        while (nums[index] == target) {
            index++;
            count++;
        }
        return count;
    }
};
```

### 剑指 Offer 39. 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:

输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2

**思路**：

排序，中间的数必然是该数字。

```jsx
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
    let newNums = nums.sort();
    return newNums[nums.length >> 1]
};
```

**官方题解**：

使用哈希表来计数

```jsx
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
    // let newNums = nums.sort();
    // return newNums[nums.length >> 1]
    let map = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], (map.get(nums[i]) || 0) + 1);
    }
    return Array.from(map).sort((a, b) => b[1] - a[1])[0][0];
};
```

`Array.from(map).sort((a, b) => b[1] - a[1])[0][0]`，`Array.from(map)`得到一个二维数组，`sort((a, b) => b[1] - a[1])`根据`value`对其降序排列，得到的二维数组中的`[0][0]`就是要得到的`key`。

### 剑指 Offer 40. 最小的k个数

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

示例 1：

输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]

**自己思路**：

降序排列，切割字符串返回。

```jsx
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function (arr, k) {
    let arr1 = arr.sort((a, b) => a - b);
    return arr1.slice(0,k);
};
```

**官方题解**：

快速排序

### 剑指 Offer 50. 第一个只出现一次的字符

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

示例 1:

输入：s = "abaccdeff"
输出：'b'

示例 2:

输入：s = ""
输出：' '

**思路**：

使用哈希表

```jsx
/**
 * @param {string} s
 * @return {character}
 */
var firstUniqChar = function (s) {
    // 使用map
    let map = new Map();
    for (let i = 0; i < s.length; i++) {
        map.set(s[i], (map.get(s[i]) || 0) + 1);
    }
    let arr = Array.from(map)
    for (let i = 0; i < arr.length; i++) {
        if(arr[i][1] == 1){
            return arr[i][0];
        }
    }
    return ' '
};
```

**题解**：

巧用`indexOf`

```jsx
var firstUniqChar = function(s) {
    for(let i of s) { // 字符串也是类数组
        if(s.indexOf(i)===s.lastIndexOf(i)) return i
    }
    return ' '
};
```

### 20. 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

**示例 1：**

输入：s = "()"
输出：true

**示例 2：**

输入：s = "()[]{}"
输出：true

**自己思路**：

使用两个栈，三次遍历即可。

// 没考虑到闭合的问题，`({)}`应该返回`false`，而不是`true`。

**题解**：

**使用辅助栈**

```jsx
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    const stack = [];
    for (let i = 0; i < s.length; i++) {
        if (['(', '{', '['].includes(s[i])) {
            stack.unshift(s[i]);
        } else if (['()', '{}', '[]'].includes(stack[0] + s[i])) {
            stack.shift();
        } else {
            return false;
        }
    }
    return stack.length == 0;
};
```

### 121、买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104

**自己思路**：

1. 暴力解析，逐个比对，取最大。
2. 动态规划，设计出状态方程。

// 动态规划都超时？？不理解啊！

解決：減少使用库函数，使用if-else做判断会减小复杂度。

```jsx
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
    // 需要理解题目的意思
    // 暴力解析的话，需要双重遍历，时间复杂度为O(n^2)。
    // let res = 0;
    // for (let i = 0; i < prices.length; i++) {
    //     for (let j = i; j < prices.length; j++) {
    //         if (prices[j] - prices[i] >= 0) {
    //             res = ((prices[j] - prices[i]) > res) ? (prices[j] - prices[i]) : res;
    //         }
    //     }
    // }
    // return (res > 0) ? res : 0;
    // RNM，超时了！
    // 不能使用暴力解析，那咋办呢？
    // 动态规划：设计状态方程=>
    // 前i天的最大收益 = max(前i-1天的最大收益,第i天的价格-前i-1天中的最小价格)
    // let maxNum = [];   
    // maxNum.push(0);
    // for (let i = 1; i < prices.length; i++) {
    //     maxNum.push(Math.max(maxNum[i - 1], prices[i] - Math.min(...(prices.slice(0, i)))));
    // }
    // return Math.max(...maxNum);
    // 还是超出时间限制？？这咋办呢？
    
    let maxNum = []; // 存放每天的最大收益
    maxNum.push(0);
    let min = prices[0]; // 存放前i-1天的最小价格
    for (let i = 1; i < prices.length; i++) {
        if (min > prices[i - 1]) {
            min = prices[i - 1];
        }
        maxNum.push(Math.max(maxNum[i - 1], prices[i] - min));
    }
    return Math.max(...maxNum);
};
```

### 283、移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下**原地对数组进行操作**。

示例 1:

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

示例 2:

输入: nums = [0]
输出: [0]

提示：1 <= nums.length <= 104；-231 <= nums[i] <= 231 - 1

**自己思路**：使用原生方法`splice`原地对数组进行添加，删除和插入（第二个参数为`0`时，从尾部插入）元素。

```jsx
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
    for (let i = 0, j = nums.length - 1; i < nums.length; ++i) {
        if (i >= j) {
            return nums;
        }
        if (nums[i] == 0) {
            nums.push(0);
            nums.splice(i, 1);
            i--;
            j--;
        }
        // splice的第一个参数是start，代表着从第i个元素开始（原数组的nums[0]是第一个），第二个参数是1，如果是就删除，删除第i个元素后面的那个。

    }
    // return nums.sort((a, b) => b ? 0 : -1); // 优雅！
};
```

**题解**：

### 1047、删除字符串中的所有相邻重复项

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

提示：1 <= S.length <= 20000；S 仅由小写英文字母组成。

**题解**：

使用辅助栈思想。

```jsx
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function (s) {
    // 辅助栈，最后的栈内元素被转为字符串并返回。
    const stk = [];
    for (const item of s) {
        // 每次与栈顶元素相比，如果相同就将栈内元素弹出，不同就压入栈内。
        if (stk.length && stk[stk.length - 1] === item) {
            stk.pop();
        } else {
            stk.push(item);
        }
    }
    return stk.join('');
};
```

### 剑指 offer 48. 找出最长不重复子串

例：str='aaabcdddd',最长不重复子串为  ‘abcd’  长度为4

```JS
// 找出最长不重复子串
const lengthOfLongestSubstring = (str) => {
  // 滑动窗口
  let len = str.length,
    left = 0,
    right = 0,
    res = 0;
  const map = new Map();
  while (right < len) {
    let s = str[right];
    if (map.has(s)) {
      map.set(s, map.get(s) + 1);
    } else {
      map.set(s, 1);
    }
    right++;
    // 有重复的
    while (map.get(s) > 1) { // 直到不重复
      let c = str[left];
      map.set(c, map.get(c) - 1);
      left++;
    }
    res = res > right - left ? res : right - left;
  }
  return res;
};

console.log(lengthOfLongestSubstring("aaasdfdd"));  // 4
```

### 剑指 Offer 57. 和为s的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]

**自己思路**：

二分查找即可，时间复杂度为O(nlogn)

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
    // 有序数组和查找问题，首先考虑二分查找。
    for (let i = 0; i < nums.length; i++) {
        let get = BinarySearch(nums, target - nums[i], 0, nums.length - 1);
        // 对nums[i]，查找的key为：target - nums[i]
        if (get) {
            return [nums[i], nums[get]]
        }
    }
};

// 实现二分查找
// 输入：有序数组，key值
// 输出：key值对应的索引
const BinarySearch = function (nums, key, left, right) {
    if (left > right) return null;
    let mid = (left + right) >> 1;
    let midVal = nums[mid];
    if (midVal < key) {
        return BinarySearch(nums, key, mid + 1, right);
    } else if (midVal > key) {
        return BinarySearch(nums, key, left, mid - 1);
    } else {
        return mid;
    }
};
```

### 剑指 Offer 61. 扑克牌中的顺子

从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

示例 1:

输入: [1,2,3,4,5]
输出: True

示例 2:

输入: [0,0,1,2,5]
输出: True

**思路**：

考虑零以外的数组去重，以及最大差值小于等于4即可。

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var isStraight = function (nums) {
    // 考虑到顺子是不分顺序的，只在乎最大差值
    // 对于大小王的考虑，直接剔除即可，差值s等于4即可
    let newNums = nums.filter(item => item != 0);
    let resN = Math.max(...newNums) - Math.min(...newNums);
    let newLen = [...new Set(newNums)].length;
    if (newNums.length != newLen) {
        return false;
    }
    if (resN <= 4) {
        return true;
    } else {
        return false;
    }
};
```

### 剑指 Offer 57 - II. 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

**思路**：

1. 使用**滑动窗口**，从1开始，左右窗口只往右移动。
2. 等差数列 sum = (i+j)(j-i+1)/2
3. sum 大于target时，i+1;小于target，j+1;
4. 循环条件：i<j && i<target/2

```js
/**
 * @param {number} target
 * @return {number[][]}
 */
const findContinuousSequence = (target) => {
    let i = 1, j = 2, sum = 0;
    let numsList = [];
    while (i < j && i < target / 2) {
        let list = [];
        sum = (i + j) * (j - i + 1) / 2;
        if (sum < target) {
            j++;
        } else if (sum > target) {
            i++;
        } else {
            for (let n = i; n <= j; n++) {
                list.push(n);
            }
            numsList.push(list);
            // 找到一组数据之后，右窗口移动，继续寻找。
            j++;
        }
    }
    return numsList;
};
```

### 121、买卖股票的最佳时机

> 买卖一次，获得最大收益。

之前做过，使用动态规划做的，使用dp来记录每天的最大收益，再去dp的最大值即可。

但如果一直更新min和max，效率会更高。

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
    // 贪心算法 O(n) + O(1)
    let min = prices[0];
    let max = 0;
    for (let i = 0; i < prices.length; i++) {
        if (min > prices[i]) {
            min = prices[i];
        }
        if (max < prices[i] - min) {
            max = prices[i] - min;
        }
    }
    return max;
};
```

### 进阶版

> 买卖K次，获得最大收益。

```js
// 方法一：动态规划
const maxProfit = (prices) => {
    const n = prices.length;
    const dp = new Array(n).fill(0).map((v) => new Array(2).fill(0)); // 初始化状态数组
    (dp[0][0] = 0), (dp[0][1] = -prices[0]); // 3.定义初始值
    for (let i = 1; i < n; ++i) {
        // 1.确定状态
        // 2.推导状态转移方程
        // 当前没持有股票，可由前一天的两种状态转移过了，
       // 1是前一天没持有，今天不动，2是前一天持有，今天卖掉，求这两种情况的较大值
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        // 当前持有股票，可由前一天的两种状态转移过了，
       // 1是前一天持有，今天不动，2是前一天没持有，今天买入，求这两种情况的较大值
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    // 4.确定输出值
    return dp[n - 1][0]; // 返回第n-1天的最大值
};

// 方法二：基于方法一做空间压缩
var maxProfit = function (prices) {
    const n = prices.length;
    let dp0 = 0,
        dp1 = -prices[0];
    for (let i = 1; i < n; ++i) {
        let newDp0 = Math.max(dp0, dp1 + prices[i]);
        let newDp1 = Math.max(dp1, dp0 - prices[i]);
        dp0 = newDp0;
        dp1 = newDp1;
    }
    return dp0;
};

// 方法三：贪心算法
// 思路：我们一直遵守的是只有赚钱才做买卖操作。
// 连续上涨日：收益为prices[i] - prices[i - 1]。
// 连续亏损日：我们就不买卖，收益为0.
// 所以我们每天资产增加的数量为Math.max(0, prices[i] - prices[i - 1])
var maxProfit = function(prices) {
    let result = 0;
    for(let i = 1; i< prices.length; i++){
        result += Math.max(0, prices[i] - prices[i - 1]);
    }
    return result;
};
```

### 1556、千分位隔数

给你一个整数 n，请你每隔三位添加点（即 "." 符号）作为千位分隔符，并将结果以字符串格式返回。

示例 1：

输入：n = 987
输出："987"

示例 2：

输入：n = 1234
输出："1.234

```js
/**
 * @param {number} n
 * @return {string}
 */
var thousandSeparator = function (n) {
    let temp = '';
    let s = n.toString();
    let sArr = Array.from(s).reverse();
    for (let i = 0; i < sArr.length; i++) {
        if ((i + 1) % 3 == 0) {
            temp += sArr[i] + '.';
        } else {
            temp += sArr[i];
        }
    }
    let len = temp.length - 1;
    if (temp[temp.length - 1] == '.') {
        temp = temp.slice(0, len)
    }
    // join需要给入参来确定连接的形式，不给入参就还是会有逗号。
    return Array.from(temp).reverse().join('');
};
```

### 461、汉明距离

两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

示例 1：

输入：x = 1, y = 4
输出：2

解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。

**自己思路**：

先填充0，再逐个比较计数。比较笨

```js
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function (x, y) {
    // 直接转为数组
    let h_x = [...(x.toString(2))];
    let h_y = [...(y.toString(2))];
    let count = 0;
    if (h_x.length != h_y.length) {
        let dif = Math.abs(h_x.length - h_y.length);
        let temp = new Array(dif).fill(0);
        h_x = h_x.length < h_y.length ? temp.concat(h_x) : h_x;
        h_y = h_x.length > h_y.length ? temp.concat(h_y) : h_y;
    }
    // 翻转之后，逐个比较
    h_x.reverse();
    h_y.reverse();
    let len = h_x.length >= h_y.length ? h_x.length : h_y.length;
    for (let i = 0; i < len; i++) {
        if (h_x[i] != h_y[i]) {
            count++;
        }
    }
    return count;
};
```

**题解思路**：

1. 使用字符串的内置函数 `padStart`来实现填充

ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度(第一个入参位置)，会在头部或尾部补全。`padStart()`用于头部补全，`padEnd()`用于尾部补全。

```js
var hammingDistance = function(x, y) {
    x = x.toString(2);
    y = y.toString(2);
    let maxLength = Math.max(x.length, y.length);
    x = x.padStart(maxLength, 0);
    y = y.padStart(maxLength, 0);
    let ans = 0;
    for (let i = 0; i < maxLength; i++) {
        if (x[i] !== y[i]) ans++;
    }
    return ans;
};
```

2. 位运算：使用异或，二者异或之后，找出1的个数即可。

```js
var hammingDistance = function (x, y) {
    let temp = x ^ y;
    let s = temp.toString(2);
    let count = 0;
    for (let i = 0; i < s.length; i++) {
        if (s[i] == 1) count++;
    }
    return count;
};
```

### 69、x的平方根

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

**注意**：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

示例 1：

输入：x = 4
输出：2

示例 2：

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。

**思路**：二分查找

```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function (x) {
  // 整数x的平方根一定是在1到x的范围内
  let left = 1,
    right = x;
  while (left <= right) {
    // 中间值  下面这样写是防止溢出
    let mid = left + ((right - left) >> 1);
    // 判断mid的平方是否小于或等于x，如果mid的平方小于x
    if (mid <= x / mid) {
      // 判断(mid+1)的平方是否大于x，如果(mid+1)的平方大于x，那么mid就是x的平方根
      if (mid + 1 > x / (mid + 1)) {
        return mid;
      }
      // 如果mid的平方小于x并且(mid+1)的平方小于x，那么x的平方根比mid大，接下来搜索从mid+1到x的范围
      left = mid + 1;
    } else {
      // 如果mid的平方大于x，则x的平方根小于mid，接下来搜索1到mid-1的范围
      right = mid - 1;
    }
  }
  // 如果输入参数是0，left等于1而right等于0，就直接返回0
  return 0;
};
```

### 判断是否是`N`的幂

```jsx
//  使用位运算和.toString()方法，以下是4的幂次，力扣击败百分之九十八！
function isPowerOfFour(num) {
  let s = num.toString(4);
  if (s[0] == 1) {
    for (let i = 1; i < s.length; i++) {
      if (s[i] != 0) {
        return false;
      }
    }
    return true;
  }
  return false;
}
```

### 搜索二维矩阵

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

思路：二分法的变种！

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function (matrix, target) {
    let m = matrix.length - 1, n = matrix[0].length - 1;
    let i = 0, j = m;
    while (i <= n && j >= 0) {
        if (matrix[j][i] > target) {
            j--;
        } else if (matrix[j][i] < target) {
            i++;
        } else if (matrix[j][i] == target) {
            return true;
        }
    }
    return false;
};
```

## 问题&方法 整理归纳

贪心

- 买卖股票最佳时间

动态规划

- 青蛙跳
- 爬楼梯
- 买卖股票最佳时间

滑动窗口

- 和为S的连续正数序列

辅助栈

- 删除字符串中的所有相邻重复项

哈希表

- 环形链表
- 两数之和

递归

- 前/中/后序遍历
- 对称二叉树
- 翻转二叉树

回溯

- 组合问题（没顺序要求）
- 切割问题（切割成回文子串）
- 子集问题
- 排列问题（要求有顺序）
- 棋盘问题（N皇后）

回溯模板：

```js
void backtracking(..args){
  if(终止条件){
    搜集结果，return
  }
  for(集合元素){
    处理节点；递归函数；回溯操作；
  }
  return
}
```

位运算

- 异或(`^`)找不同
- `toString(n)`，转换进制，进行进制操作

分治法

- 二分查找

## 面试准备

### 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```js
var permute = function(nums) {
    const result = [];
    const book = {};
    const res = [];
    // 深度优先遍历，排列组合，思路类似于有n个萝卜，填k个坑。
    // 步骤示意图：
    // dfs(0) 1 -> dfs(1) -> 由于萝卜1已被用，所以1不能用，跳过，填2，-> dfs(2) -> 和前面相似，这里只能填3-> 最后一步，把当前结果填到集合；
    // 回溯到dfs(1), 这里还可以填3，然后再填2，最后得到1-> 3 -> 2 。把当前结果填到集合；
    // 第二个坑位回溯完，然后再回溯到第一个坑位
    // 第一个坑位可以先填2，
    // 然后依次得到： 2->1->3， 2->1->3
    function dfs(step, targetArr) {
        const total = targetArr.length;
        // 当轮询完所有坑位时，将前面轮询的结果放入最后的集合中
        if (step === total) {
            result.push(res.slice());
            return;
        }
        for (let i = 0; i < total; i++) {
            const target = targetArr[i];
          if (!book[target]) {
            res[step] = target;
            // 标记：当前坑位已经被占用
            book[target] = 1;
            dfs(step + 1, targetArr);
            // 当前轮次已排完，清除标记
            book[target] = 0;
          }
        }
    }
    dfs(0, nums);
    return result;
};
```

### `LRU` 缓存机制

思路：使用`map`来解决问题。
获取的时候如果存在那么就需要更新一次位置到最新。
设置的时候如果存在就删除了，如果到达最大长度就删除第一个。
`this.map.keys()` 会调用`map`的`[Symbol.iterator]`生成迭代器，`.next()`获取key。

```js
var LRUCache = function(capacity) {
    this.capacity = capacity
    this.map = new Map()
};

LRUCache.prototype.get = function(key) {
    let has = this.map.has(key)
    if(has){
        let value = this.map.get(key);
        this.map.delete(key)//删除重新设置，会更新位置
        this.map.set(key,value);
        return this.map.get(key)
    }
    return -1
};

LRUCache.prototype.put = function(key, value) {
    if(this.map.has(key)){  //存在则删除
        this.map.delete(key)
    }
    if(this.map.size == this.capacity){ //如果到达临界值就需要删除第一个
        const {value : key, done} = this.map.keys().next()
        this.map.delete(key)
    }
    this.map.set(key,value)
};
```

### 比较版本号

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '`.`' 连接。每个修订号由多位数字组成，可能包含前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从0开始，最左边的修订号下标为0 ，下一个修订号下标为1 ，以此类推。例如，2.5.33 和 0.1都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。也就是说，修订号1和修订号001相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，版本1.0 小于版本1.1，因为它们下标为0的修订号相同，而下标为1的修订号分别为0和1，0 < 1。

返回规则如下：

如果 version1 > version2 返回 1，
如果 version1 < version2 返回 -1，
除此之外返回 0。

示例 1：

输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"

```js
const compareVersion = (version1, version2) => {
    // 使用'.'将版本号分割成为数组
    const [v1, v2] = [version1.split('.'), version2.split('.')];
    // 取两者长度的最大值
    const len = Math.max(v1.length, v2.length);
    for (let i = 0; i < len; i++) {
        // 数组元素逐个转换成数字，比较大小
        // 数组若越界，则定义为0
        const num1 = v1[i] ? parseInt(v1[i]) : 0;
        const num2 = v2[i] ? parseInt(v2[i]) : 0;
        if (num1 > num2) {
            return 1;
        } else if (num1 < num2) {
            return -1;
        }
    }
    // 还没有返回，说明两者相等
    return 0;
};
```

### 三数之和

题解：

- 外层循环：指针 i 遍历数组。
- 内层循环：用双指针，去寻找满足三数之和 == 0 的元素。

先排序的意义：便于跳过重复元素，如果当前元素和前一个元素相同，跳过。

双指针的移动时，避免出现重复解。找到一个解后，左右指针同时向内收缩，为了避免指向重复的元素，需要：

1. 左指针在保证left < right的前提下，一直右移，直到指向不重复的元素。
2. 右指针在保证left < right的前提下，一直左移，直到指向不重复的元素。

小优化：排序后，如果外层遍历的数已经大于0，则另外两个数一定大于0，sum不会等于0，直接break。

```js
const threeSum = (nums) => {
  nums.sort((a, b) => a - b); // 排序

  const res = [];

  for (let i = 0; i < nums.length - 2; i++) { // 外层遍历
    let n1 = nums[i];
    if (n1 > 0) break; // 如果已经爆0，不用做了，break
    if (i - 1 >= 0 && n1 == nums[i - 1]) continue; // 遍历到重复的数，跳过    

    let left = i + 1;            // 左指针
    let right = nums.length - 1; // 右指针

    while (left < right) {
      let n2 = nums[left], n3 = nums[right];

      if (n1 + n2 + n3 === 0) {  // 三数和=0，加入解集res
        res.push([n1, n2, n3]);
        while (left < right && nums[left] == n2) left++; // 直到指向不一样的数
        while (left < right && nums[right] == n3) right--; // 直到指向不一样的数
      } else if (n1 + n2 + n3 < 0) { // 三数和小于0，则左指针右移
        left++;
      } else {      // 三数和大于0，则右指针左移
        right--;
      }
    }
  }
  return res;
};
```

### N数之和

### 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

示例1:

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1 // 只有一片岛屿

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
const numIslands = (grid) => {
    //深度优先
    let count = 0;
    let m = grid.length;
    let n = grid[0].length;
    const dfs = (i, j) => {
        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] === '0') return;//下标越界或不是陆地，返回
        grid[i][j] = '0';//将陆地置为水，避免后续访问重复计算这个位置
        //检验它的上下左右方向有没有陆地
        dfs(i + 1, j);
        dfs(i - 1, j);
        dfs(i, j + 1);
        dfs(i, j - 1);
    }
    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            if(grid[i][j] === '1') {//找到陆地
                dfs(i, j);//找到这个陆地所属的一整块岛屿，整个岛屿原本的的'1'都被置为'0'
                count++;//岛屿数量增加
            }
        }
    }
    return count;
};
```

### 最长严格递增子序列

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
const findLengthOfLCIS = (nums)=> {
    // 使用队列
    let max = 0; // 最大长度
    let arr = []; // 队列
    for(let i=0;i<nums.length;i++){
        arr.push(nums[i]);
        if(max<=arr.length){
            max = arr.length;
        }
        if(nums[i+1]<=arr[arr.length-1]){
            arr = [];
        }
    }
    return arr;
};
```

### 最长公共子序列

```js
// 方法：动态规划
// 思路：注意子序列可以不连续
// 状态定义：dp[i][j]表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列，注意是闭区间，之所以是到i-1或j-1，是方便初始化dp数组，当i=0或者j=0的时候表示的就是空字符和另一个字符串匹配，此时的dp[i][j]=0。
// 状态转移方程：当text1[i - 1] == text2[j - 1]时：dp[i][j] = dp[i - 1][j - 1] + 1
// 当text1[i - 1] != text2[j - 1]时：dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
// dp的初始化：当 i = 0 时：dp[0][j]=0
// 当 j = 0 时：dp[i][0]=0
// 返回结果：dp[len(text1)][len(text2)]

// 复杂度：时间复杂度O(mn)，空间复杂度O(mn)
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));//初始化dp
    for (let i = 1; i <= m; i++) {
        const c1 = text1[i - 1];
        for (let j = 1; j <= n; j++) {
            const c2 = text2[j - 1];
            if (c1 === c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;//text1与text2字符相同时 最长公共子序列长度+1
            } else {
               //text1与text2字符不同时 返回text1或text2向前减少一位之后的最长公共子序列中的较大者
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```

### 最大回文长度

```js
// dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]；
// 如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2；
// 如果s[i]与s[j]不相同，dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])；
// dp数组初始化：dp[i][i]即主对角线肯定都是1，其他全为0即可；
// dp[i][j]依赖dp[i + 1][j - 1]、所以需要从下往上、从左往右遍历。

const longestPalindromeSubseq = s => {
    // 字符串长度
    const len = s.length;
    // 创建dp数组
    const dp = new Array(len).fill(0).map(x => new Array(len).fill(0));
    // dp数组初始化，矩阵主对角线都为1
    for (let i = 0; i < len; i++) dp[i][i] = 1;

    // 遍历顺序，从下往上，从左往右
    for (let i = len - 1; i >= 0; i--) {
        for (let j = i + 1; j < len; j++) {
            // 根据s[i]和s[j]的关系更新dp[i][j]
            if (s[i] === s[j]) {
                // 头尾相等，则dp[i][j]等于减去头尾的数量+2
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                // 头尾不相等，则dp[i][j]等于减去头或减去尾的最大值
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    // 返回字符串的头到尾的数量
    return dp[0][len - 1];
};
```
